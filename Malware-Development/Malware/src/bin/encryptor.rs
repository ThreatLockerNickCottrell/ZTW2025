/* 
use std::fs::File;
use std::io::{self, Read, Write};

use malware_examples::encryption;

fn main() {
    // Prompt the user for input method
    print!("Enter '1' to input data manually or '2' to read from a file: ");
    io::stdout().flush().unwrap(); // Ensure the prompt is displayed

    // Collecting choice made
    let mut choice = String::new();
    io::stdin().read_line(&mut choice).unwrap();
    let choice = choice.trim();

    let data = match choice {
        "1" => {
            // Prompt the user for input
            print!("Enter the data to encrypt: ");
            io::stdout().flush().unwrap(); // Ensure the prompt is displayed

            let mut data = String::new();
            io::stdin().read_line(&mut data).unwrap();
            data.trim().to_string() // Remove any trailing newline characters
        }
        "2" => {
            // Read data from a file
            print!("Enter the file path: ");
            io::stdout().flush().unwrap(); // Ensure the prompt is displayed

            let mut file_path = String::new();
            io::stdin().read_line(&mut file_path).unwrap();
            let file_path = file_path.trim();

            let mut file = File::open(file_path).expect("Failed to open file");
            let mut file_data = String::new();
            file.read_to_string(&mut file_data)
                .expect("Failed to read file");
            file_data.trim().to_string() // Remove any trailing newline characters
        }
        _ => panic!("Please give a valid choice"),
    };

    // Prompt the user for a salt
    print!("Enter your salt or press Enter to generate one: ");
    io::stdout().flush().unwrap(); // Ensure the prompt is displayed

    // Collecting salt string
    let mut salt = String::new();
    io::stdin().read_line(&mut salt).unwrap();
    salt = salt.trim().to_string();

    if salt.is_empty() {
        salt = encryption::generate_salt();
    }

    let encrypted_data = encryption::encrypt(data.as_str(), salt.as_str());
    println!("Salt: {}", salt);

    match choice {
        "1" => println!("Encrypted: {}", encrypted_data),
        "2" => {
            // Write the salt and encrypted data back to the file in the format salt,data
            print!("Enter the output file path: ");
            io::stdout().flush().unwrap(); // Ensure the prompt is displayed

            let mut output_file_path = String::new();
            io::stdin().read_line(&mut output_file_path).unwrap();
            let output_file_path = output_file_path.trim();

            let mut output_file =
                File::create(output_file_path).expect("Failed to create output file");
            output_file
                .write_all(format!("{}{}", salt, encrypted_data).as_bytes())
                .expect("Failed to write contents");
            output_file.flush().expect("Failed to flush output");

            println!(
                "Salt and encrypted data have been written to {}",
                output_file_path
            );
        }
        _ => unreachable!(),
    };
}
*/

use clap::{command, Parser, ValueEnum};
use malware_examples::encryption::{self, generate_salt};
use std::{fs::File, io::{Read, Write}, path::PathBuf};

#[derive(Parser)]
#[command()]
struct CliParser {
    /// Optional file to encrypt
    #[arg(short, long)]
    file: Option<PathBuf>,
    #[arg(short, long)]
    input_string: Option<String>,
    #[arg(short, long)]
    mode: Mode,
    #[arg(short, long)]
    salt: Option<String>,
    #[arg(short, long)]
    output_file: Option<PathBuf>,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum Mode {
    Encrypt,
    Decrypt,
}
fn main() {
    let command_parser = CliParser::parse();
    let mode = command_parser.mode;
    let mut data=String::new();
    let salt = command_parser.salt.unwrap_or_default().to_string();
    
    if let Some(file_path) = command_parser.file {
        let mut file = File::open(file_path).expect("Couldnt open file");
        file.read_to_string(&mut data).expect("Failed to read from file");
    } else if let Some(input_data) = command_parser.input_string{
        data =input_data;
    } else {
        return;
    }

    let result_data = match mode {
        Mode::Encrypt => {
            //Check if salt is supply
            let salt = if salt.is_empty() {
                generate_salt()
            } else {
                salt
            };
            let encrypted_data = encryption::encrypt(data.as_str(), salt.as_str());
            println!("Encrypted data: {}", encrypted_data);
            println!("Salt: {}", salt.as_str());
            println!("{},{}" ,salt.as_str() , encrypted_data);
            (salt, encrypted_data)
        },
        Mode::Decrypt => {
            if salt.is_empty(){
                eprintln!("Salt cannot be empty.");
                return;
            }
            let decrypted_data = encryption::decrypt(data.as_str(), salt.as_str());
            println!("Decrypted data: {}", decrypted_data);
            (salt, decrypted_data)
        },
    };

    // writing output to file or printing it to stdout
    match command_parser.output_file {
        Some(output_file) => {
            let mut out_file = File::create(output_file).expect("output file");
            let result_string = format!("{},{}", result_data.0, result_data.1);
            out_file.write_all(result_string.as_bytes()).expect("Failed to write contents");
            out_file.flush().expect("failed to flush");
        },
        None => (),
    }
}