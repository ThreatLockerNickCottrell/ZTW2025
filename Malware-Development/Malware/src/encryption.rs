use rand::Rng;
use hex;

/**
 * Generates a salt for use in encryption
 */
pub fn generate_salt() -> String {
    let mut rng = rand::rng();
    let salt: [u8; 16] = rng.random(); // Generate a 16-byte random salt
    hex::encode(salt) // Encode the salt to a hex string
}

/**
 * XOR encrypts/decrypts the data with the given key
 */
fn xor(data: &[u8], key: &[u8]) -> Vec<u8> {
    data.iter()
        .zip(key.iter().cycle())
        .map(|(&x, &k)| x ^ k)
        .collect()
}

/**
 * Encrypts a given string and salt into an XOR encrypted string
 */
pub fn encrypt(data: &str, salt: &str) -> String {
    let salted_data = format!("{}{}", salt, data);
    let encrypted_data = xor(salted_data.as_bytes(), salt.as_bytes());
    hex::encode(encrypted_data)
}
/**
 * Encrypts into the format
 */
pub fn encrypt_format(data: &str, salt: &str) -> String {
    println!("data{}", data);
    println!("salt{}", salt);
    let encrypted_data = encrypt(data, salt);
    format!("{},{}", salt, encrypted_data)
}

/**
 * Decrypts the string by decoding the hex and stripping the salt
 */
pub fn decrypt(encrypted_data: &str, salt: &str) -> String {
    let decoded_data = hex::decode(encrypted_data.trim()).expect("Failed to decode data");
    let decrypted_data = xor(&decoded_data, salt.as_bytes());
    let decrypted_str = String::from_utf8(decrypted_data).expect("Failed to convert decoded data to string");

    // Remove the salt from the decoded string
    let original_data = match decrypted_str.strip_prefix(salt) {
        Some(result) => result,
        _ => decrypted_str.as_str(),
    };

    original_data.to_string()
}

/**
 * Decrypts the the formated string to return decoded data
 */
pub fn decrypt_format(input: &str) -> String {
    let (salt, data) = split_salt_and_data(input);
    let unencoded_data = decrypt(&data, &salt);
    unencoded_data
}
/**
 * Spits the salt and data
 */
fn split_salt_and_data(input: &str) -> (String, String) {
    let parts: Vec<&str> = input.split(',').collect();
    if parts.len() == 2 {
        (parts[0].to_string(), parts[1].to_string())
    } else {
        (String::new(), String::new())
    }
}